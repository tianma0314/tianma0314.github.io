---
layout:     post
title:     G1收集器详解
subtitle:   设计目标，内存结构，执行流程
date:       2019-04-08
author:     walker
header-img: img/scala-1.jpg
catalog: true
tags:
    - JVM
    - Language
---

> 写在前面：
>
> 1. 本文基于官网G1垃圾收集器教程的一个翻译，同时对于一些官网只是简单提及的概念做了适当的补充，官网地址如下：[Getting Started with the G1 Garbage Collector](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html)，而主要的查阅资料就是官方的虚拟机文档以及周老师的第三版深入理解Java虚拟机。
>
> 2. 本文除了会对G1收集器进行详细的介绍，也会顺带详细介绍CMS垃圾收集器作为对比，基于CMS"迟暮"的情况下，就不会另写一篇CMS文章进行专门介绍了。

## G1的设计目标

1. G1收集器是一个面向服务端的垃圾收集器，适用于多核处理器、大内存容量的服务端系统。
2. 满足短时间GC停顿（用户可控时间），同时拥有较高的吞吐量。
3. G1在JDK7以上版本适用，长期目标是替代CMS，不过JDK1.7的默认的垃圾收集器仍是CMS，我们可以通过 -XX:+UseG1GC 参数切换虚拟机的垃圾收集器，在JDK1.9中，G1已正式成为默认的垃圾收集器。

## 与CMS

1. G1在某些方面弥补了CMS的不足，比如：CMS适用mark-sweep算法，所以频繁GC之后会产生内存碎片问题，而G1适用copying算法，高效的内存整理，不需要管理内存碎片问题。
2. 另外，G1对于GC停顿时间更加可控。

## G1的堆内存结构

1. heap被划分成一个个相等的不连续的内存区域（regions），每个region都有一个分代的角色：Eden，Survivor，Old，如下图所示：

   ![g1-heap-allocation](/img/g1-heap-allocation.png)

   G1对每个角色的数量没有强制的限定，各个角色所占内存区域会动态变化。这就使得G1	对内存的使用有了更高的灵活性。

> 当执行垃圾回收时，G1操作的方式类似于CMS，G1执行并发的全局标记阶段来确定堆上的对象是否存活，标记阶段完成后，G1就知道哪些region回收的收益最大（也就是垃圾最多），它会优先回收这些region，从而产生大量的空闲空间。这就是为什么这种垃圾收集方法叫做G1（垃圾优先）。就如收集器名称所暗示的那样，G1将回收和压缩活动专注于那些可能充满了可回收对象的堆区域中。
>
> G1使用GC停顿可预测模型，来满足用户设定的GC停顿时间，根据用户设定的目标时间，G1决定清除哪些region，清除多少region。
>
> G1认为可回收的区域通过一种叫做“撤离”的方式进行垃圾回收，G1从一个或多个region中复制对象到一个region中，这个过程中G1会压缩和释放内存。处于减小停顿时间和提升吞吐量的目的，这种方式的回收是多核并行进行的。从而随着每次的GC，G1都会在用户规定的停顿时间范围内持续地降低碎片化程度（因为是copy算法，另外还有压缩）。这种方式高于之前的垃圾收集方法：CMS不会压缩，而ParallelOld只会整堆压缩，无疑这会造成相当长的停顿时间。
>
> G1并不是一个实时的垃圾收集器，它会尽可能地去将停顿时间控制在用户设定的时间范围内，但是无法保证绝对。基于前几次回收的数据，G1会估算在用户指定的目标时间内能回收多少region，因此G1对于回收region的开销有一个比较合理准确的模型供参考，它就是用这个模型来决定在用户规定时间内回收多少region。

## 垃圾回收中的一些关键概念

下面介绍一些CMS或G1在垃圾回收中会提及的数据结构及算法，如下：

1. RSets（Remembered Sets）：广义地讲，RSets是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。而针对G1来讲，heap中，每个region都有一个RSets。RSets追踪都有哪些不同分代角色region中的对象引用指向到RSets所在region，**举个例子，在Young GC时，虚拟机会扫描每个待回收region（这些region的角色是Eden或Survivor）的RSets，看里面是否有指向该region的来自老年代region的指针，如果有，那么将会扫描那个region来确定哪些对象处在GC Roots链中。注意，RSets是一种抽象结构！它的一种常见实现就是下面提到的卡表（Card Table）**

2. CSets（Collection Sets）：在G1中，一组在GC中会被回收的region集合。CSets中所有仍存活的对象在GC中会被“撤离”，就是被移动或者拷贝到另一个region中，CSets中的region角色是不固定的，可以使Eden，Survivor，Old Generation，都可以。CSets对JVM size大小的影响小于1%。

3. Card Table：卡表是RSets的一种实现，其实际数据结构在HotSpot的实现中是一个字节数组：

   ```c++
   CARD_TABLE [this address >> 9] = 0;
   ```

   字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作“卡页”（Card Page）。一般来说，卡页大小都是以2的N次幂的字节数，通过上面代码可以看出HotSpot中使用的卡页是2的9次幂，即512字节（地址右移9位，相当于用地址除以512）。那如果卡表标识内存区域的起始地址是0x0000的话，数组CARD_TABLE的第0、1、2号元素，分别对应了地址范围为0x0000～0x01FF、0x0200～0x03FF、0x0400～0x05FF的卡页内存块，如下图所示：

   ![card-table](/img/card-table.jpg)

   一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，称为这个元素变脏（Dirty），没有则标识为0。在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。

4. TAMS（Top at Mark Start）：把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围。

## 推荐使用G1的用例

G1旨在为那些需要大堆空间和低GC延迟的应用提供解决方案，堆大小最好是6GB或更大，同时稳定可预测的GC时间在0.5秒以内。当应用有如下特征时，从CMS或ParallelOldGC垃圾收集器迁移到G1的收益将会非常可观：

1. Full GC时间太长或太频繁
2. 对象的分配率或晋升率变化明显
3. 长时间的收集压缩停顿（指达到了0.5到1秒）

## CMS与G1的横向对比

### 分代垃圾回收与CMS：

- CMS是作用于老年代的垃圾收集器，它通过使垃圾回收工作和应用线程并发进行来达到最小化垃圾回收停顿时间，通常来讲，并发低延迟的收集器并不会拷贝和压缩活着的对象，回收完成之后，活着的对象是不动的，那么这就引发了潜在的碎片问题，当碎片化严重时，就会去请求一个更大的堆。

- CMS的回收各阶段如下表所示：

  | 阶段                 | 描述                                                         |
  | -------------------- | ------------------------------------------------------------ |
  | （1）初始标记（STW） | 依据可达性分析算法标记直接可达的对象，老年代中那些被标记为可达的对象也包括可能是被年轻代中的对象引用的。相对于young GC来说，初始标记的停顿时间通常会很短，因为它跟堆的大小无关，只跟GC Roots数量有关。 |
  | （2）并发标记        | 在Java应用线程执行的同时，从上一步中跟GC Roots直接关联的对象开始扫描，遍历整个对象图（相较于初始标记，更加深入，耗时也更长）。 |
  | （3）重新标记（STW） | 在并发标记阶段，有些对象会被标记为不可达，但是由于是与用户线程并发进行的，所以有可能标记过程中该不可达对象又被用户线程改变为可达的对象了，重新标记阶段的目的就是找出这部分“死而复生”的对象将其标记为可达。 |
  | （4）并发清除        | 回收在标记阶段被定义为不可达的对象，回收的对象空间会被加入到一个内存空闲列表里面，用作后续的对象空间分配。在这个阶段，合并不可达对象是可能发生的。**值得注意的是，存活对象并不会移动位置，这也是多次GC后，CMS碎片化问题会严重的根本原因所在**。 |
  | （5）重置            | 为下一次并发收集做准备，清空CMS内部数据结构。                |

  好了，上面就是CMS回收的各个阶段简介，下面我们来一步步地解析CMS的垃圾回收是如何在堆上进行的。

- 纵观CMS垃圾回收：

  1. 首先是CMS的对空间结构如下图所示，堆被分成了三块空间：Eden，Survivor，Old，其中，Eden和两块Survivor属于年轻代，而老年代，是一块连续的内存空间。对象回收动作就发生在这些地方。需要注意的是：**除非发生Full GC，否则堆上的对象是不压缩的**。

     ![CMS-heap-structure](/img/CMS-heap-structure.png)

  2. Young GC是如何进行的？

     - 首先，当Eden满了之后，会触发Young GC，年轻代的垃圾回收通常采用复制算法，将Eden区和一个Survivor区的活着的对象复制到另一个Survivor区，这其中可能会包含一些年龄（你可以理解为是经历的 Young GC次数）达到一定阈值的对象，他们会直接晋升到老年代中，而不是被复制到另一个Survivor中，对象的流动方向如下图所示：

     ![young-generation-collection](/img/young-generation-collection.png)

     - 在Young GC之后，Eden区和其中一个Survivor区会被清空，所有活着的对象都跑到了另一个Survivor区中，这样，在下次进行Young GC时，现在空着的Survivor区就可用作存放复制过来的活着的对象之用。此时堆上空间内对象分布如图所示：

     ![after-young-gc](/img/after-young-gc.png)

  3. CMS的老年代回收：

     - 当老年代的对象占用率超过一定值的时候，CMS就会开始进行回收动作。在老年代的回收中，就像前面的表格中所示，有两个STW（stop the world）阶段会发生：初始标记和重新标记阶段，这里我们不再赘述。还有一个很重要的步骤叫做并发清除，在之前的几个标记阶段中，没有被标记为活着的对象，将被CMS清除，原地清除，直接释放内存，没有对象的移动，也没有压缩。回收前后的空间对比如下面图所示：

     ![concurrent-sweep](/img/concurrent-sweep.png)

     ![after-sweep](/img/after-sweep.png)

     - 重置阶段：会重置CMS内部的数据结构，用于下一次的老年代回收工作。

- CMS的主要缺点：

  1. 因为面向并发的设计，CMS对CPU资源非常敏感，因为它总会占用一部分用户的CPU资源，CMS默认启动的回收线程数是（处理器核心数 + 3）/ 4，也就是说如果CPU核数在四个或以上时，CMS会占用不超过25%的计算资源，但是当核数不足四个时，CMS回收对用户线程的影响就比较大了。其实CMS也采取了补救策略，叫做“增量式并发收集器”，不过效果不甚理想，JDK7版本中就已经被标明不提倡使用了，JDK9更是完全废弃了，在此不提。

  2. 无法处理“浮动垃圾”，有可能出现“Con-current Mode Failure”，进而导致另一次Full GC的触发（**注意：上表中提到的重新标记阶段并不会处理浮动垃圾，从可达性的角度来看，重新标记阶段只会让对象“死而复生”，却不会让对象“去死”**）。同时，因为并发的缘故，所以需要给用户线程在堆上留有足够的空间，而不能等老年代满了再收集。

     我们可以通过-XX：CMSInitiatingOccupancyFraction参数来控制触发CMS垃圾回收的老年代占有率。这个需要根据使用者实际情况灵活调整。

  3. 因为CMS基于标记-清除算法，所以碎片问题不可避免，而JVM也给出了相应的补救策略：

     - -XX：+UseCMSCompactAtFullCollection：用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程，JDK9中已废弃。
     - -XX：CMSFullGCsBeforeCompaction：要求CMS收集器在执行过若干次（数量由参数值决定）不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理，同样，在JDK9中已废弃。

### G1的垃圾回收实现：

- G1的堆结构跟老式的收集器划分的堆结构不同，G1是把一块内存划分成了许多个均等的固定大小的区域，叫region。每块region的大小是在JVM启动时确定的，JVM通常会把堆内存区域均分成2000块左右的region，region的大小在1MB到32MB之间（它们是一样大的）。

- 每块使用上的region会被分配一个角色，Eden，SUrvivor，Old，这三种身份均可，并且同一身份的region并不要求处在连续的内存空间位置上，更加灵活。内存分配状态如下图所示：

  ![g1-heap-allocation](/img/g1-heap-allocation.png)

  当垃圾回收发生时，活着的对象会被复制或移动到其他的region中，因为每个region都可以被独立的回收，所以回收动作可以与其他线程并行执行。

  另外需要提到一点，除了Eden，Survivor，Old generation这三种角色的region之外，其实还有一种region的角色，叫做Humongous regions，这些region被设计用来装那些大于等于region大小50%的对象，**不过截止JDK8时，回收大对象还没有被很好地优化，所以你应该避免创建那么大的对象**。

- 接下来我们来正式讨论G1的垃圾回收，首先，我们需要知道的一个知识点是：G1中有两种回收模式，一个是Young GC，一个是Mixed GC。

  1. Young GC：选定所有年轻代里的region。通过控制年轻代的region个数，即年轻代内存大小，来控制young GC的时间开销。
  2. Mixed GC：选定所有年轻代里的region，外加根据concurrent marking cycle phase中统计得出在用户指定的开销目标范围内尽可能选择收益高的老年代region。我们可以简化地理解为，Mixed GC的主要目标，或者说原因，是针对老年代的回收，但是它同时会对年轻代整体进行Young GC（Mixed  GC中包含Young GC）

- G1的垃圾收集步骤：

  我们先来思考一个问题，上边我么讲到了CMS的垃圾回收操作会根据根可达性算法各种标记，然后进行GC，那么G1回收器会做这种操作吗？答案是肯定的。虽然标记阶段不是完全相同，但是大体上还是类似的思路，下面我们来看看G1的整体运作流程：

  | 阶段                 | 描述                                                         |
  | -------------------- | ------------------------------------------------------------ |
  | （1）初始标记（STW） | 存在STW，这个停顿是与Young GC共享的。仅标记出GC Roots能直接关联到的对象，同时修改TAMS指针的值，让下一阶段中并发进行的用户线程可以在region中的正确位置上分配对象空间。 |
  | （2）并发标记        | 从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。 |
  | （3）最终标记（STW） | 对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。 |
  | （4）筛选&回收       | 1. 统计存活对象，释放region内存（STW）；2. 擦除region的RSets（STW）；3. 重置已经空了的region，并将其加入到空闲列表中； STW并把存活的对象复制到还未使用的region中，如果是Young GC，日志格式是：[GC pause (young)]，如果是Mixed GC，日志格式是：[GC Pause (mixed)] |

## 总结

上面我么介绍了CMS和G1垃圾收集器的回收过程，我们知道，G1作为CMS下一代收集的身份登场，旨在解决CMS在运行过程中所暴露出来的诸多痛点，不过，G1相对于CMS仍然不是占全方位、压倒性优势的，从它出现几年仍不能在所有应用场景中代替CMS就可以得知这个结论。比起CMS，G1的弱项也可以列举出不少，如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。

就内存占用来说，虽然G1和CMS都使用卡表来处理跨代指针，但G1的卡表实现更为复杂，而且堆中每个Region，无论扮演的是新生代还是老年代角色，都必须有一份卡表，这导致G1的记忆集（和其他内存消耗）可能会占整个堆容量的20%乃至更多的内存空间；相比起来CMS的卡表就相当简单，只有唯一一份，而且只需要处理老年代到新生代的引用，反过来则不需要，由于新生代的对象具有朝生夕灭的不稳定性，引用变化频繁，能省下这个区域的维护开销是很划算的。

在执行负载的角度上，同样由于两个收集器各自的细节实现特点导致了用户程序运行时的负载会有不同，譬如它们都使用到写屏障，CMS用写后屏障来更新维护卡表；而G1除了使用写后屏障来进行同样的（由于G1的卡表结构复杂，其实是更烦琐的）卡表维护操作外，为了实现原始快照搜索（SATB）算法，还需要使用写前屏障来跟踪并发时的指针变化情况。相比起增量更新算法，原始快照搜索能够减少并发标记和重新标记阶段的消耗，避免CMS那样在最终标记阶段停顿时间过长的缺点，但是在用户程序运行过程中确实会产生由跟踪引用变化带来的额外负担。由于G1对写屏障的复杂操作要比CMS消耗更多的运算资源，所以CMS的写屏障实现是直接的同步操作，而G1就不得不将其实现为类似于消息队列的结构，把写前屏障和写后屏障中要做的事情都放到队列里，然后再异步处理。（以上内容摘自周老师的深入理解Java虚拟机第三版）

以上就是关于G1的全部内容，有些地方现在还不能很好的理解，所以无法用自己的话语清晰地表达出来，待后续有了更深刻的理解，会将本文结构，内容加以丰满。

